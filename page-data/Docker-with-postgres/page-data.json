{"componentChunkName":"component---src-templates-blog-post-js","path":"/Docker-with-postgres/","result":{"data":{"site":{"siteMetadata":{"title":"PPX Blog"}},"markdownRemark":{"id":"492e5436-9394-5bf9-bcb4-76ea7207a89c","excerpt":"Intro Using Docker container to implement a PostgreSQL is not quite easy for a newcomer in Docker. Especially for those who are not familar with Database, it’s…","html":"<h2>Intro</h2>\n<p>Using Docker container to implement a PostgreSQL is not quite easy for a newcomer in Docker. Especially for those who are not familar with Database, it’s very hard to configure and set everything correct. So that’s why this artical is created. Let’s start from a simple docker compose file.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres</code></pre></div>\n<h2>Docker compose’s initialization</h2>\n<p>If you are not using a dockerfile to creating a Postgre image, instead, you are using docker compose file to directly a Postgre container, a lot of things will be done by the Docker itself. For example the <code class=\"language-text\">host name</code> of the database is the <code class=\"language-text\">container_name</code> you set for the db container. </p>\n<h4>User, password and Database</h4>\n<p>It will also generate a user using the password and database name you provided in the envrionment variables.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=testdb</code></pre></div>\n<h4>Connection db</h4>\n<p>So when you are writing the backend code to connect the database, you can use these values for connection. </p>\n<p>A example with gorm in Golang is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import (\n        &quot;gorm.io/driver/postgres&quot;\n        &quot;gorm.io/gorm&quot;\n)\n\ndsn := &quot;postgres://postgres:pass@test-postgres/testdb&quot;\ndb, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})</code></pre></div>\n<h4>Database initilization</h4>\n<p>To initilizate a database, you can use Docker volumes.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=testdb\n    volumes:\n      - ./migrations/init.sql:/docker-entrypoint-initdb.d/init.sql\nvolumes:\n  postgres:</code></pre></div>\n<p>With this, init.sql will be run once the container starts.</p>\n<p>Notice: When the database container’s data directory is empty, the initilization script/sql won’t be run.</p>\n<h4>networks and ports</h4>\n<p>If you want to use container’s name as the host name and provide another container from same or different networks the access to the postgres db, you need to setup network and ports.</p>\n<p>Using <code class=\"language-text\">networks</code>, all containers in the same compose fill will be running under the same specified network, which allows to call host name directly.</p>\n<p>Using <code class=\"language-text\">ports</code>, you can specify the outside port the postgres container. So when a service from different network trying to access the postgres db, it can use that port.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=testdb\n    volumes:\n      - ./migrations/init.sql:/docker-entrypoint-initdb.d/init.sql\n    ports:\n      - 5432:5432\n    networks:\n      - test-network\nvolumes:\n  postgres:\n\nnetworks:\n  test-network:\n    name: test-network</code></pre></div>\n<h2>First come first served</h2>\n<p>Docker enables the dependency feature which allows you specify which service to run first and second. This is important because database’s initialization may take time and is usually slower than the startup of backend services.</p>\n<p>However, the dependency only makes sure which services will run first, but Postgres container won’t give a sign that the initialization is done. Docker compose will only know when database service is started successfully and will let it finish the remaining job, and start the next service. </p>\n<p>So usually when Docker starts the backend service, the init process isn’t done, which will cause various errors such as <code class=\"language-text\">dial tcp [::1]:5432: connect: connection refused docker</code> and <code class=\"language-text\">FATAL:  role &quot;root&quot; does not exist</code>. </p>\n<p>I chose <code class=\"language-text\">health check</code> and <code class=\"language-text\">condition depend</code> on in Docker to solve the problem.</p>\n<h4>Healthcheck</h4>\n<p>The healthcheck feature in Docker will check run some user defined commands and see if there is any error (exit code 1) returned depending on the timeout, intervals, and retries you set.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=testdb\n    volumes:\n      - ./migrations/init.sql:/docker-entrypoint-initdb.d/init.sql\n    ports:\n      - 5432:5432\n    networks:\n      - test-network\n    healthcheck:\n      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U postgres&quot;]\n\nvolumes:\n  postgres:\n\nnetworks:\n  test-network:\n    name: test-network</code></pre></div>\n<h4>Conditional depends on</h4>\n<p>As I mentioned before the <code class=\"language-text\">depends on</code> in Docker compose is not working well. However, we can add some condition to it and make it working with healthcheck.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  backendserver:\n    build: &quot;.&quot;\n    ports:\n      - &quot;8080:8080&quot;\n    depends_on:\n      postgres:\n        condition: service_healthy\n    network:\n      - test-network</code></pre></div>\n<p>It will run the health check command in the service <code class=\"language-text\">postgres</code> and will only start this service if the condition is passed.</p>\n<h2>Some other points when configing Docker with Postgres</h2>\n<p>Some other things I may mention next time include <code class=\"language-text\">environment variables</code>, other usage of volums and how to set correct interval, timeout and retires in healthcheck.</p>\n<h2>Appendix</h2>\n<h3>Full docker compose file</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">version: &quot;3.6&quot;\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: test-postgres\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=pass\n      - POSTGRES_DB=testdb\n    volumes:\n      - ./migrations/init.sql:/docker-entrypoint-initdb.d/init.sql\n    ports:\n      - 5432:5432\n    networks:\n      - test-network\n    healthcheck:\n      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U postgres&quot;]\n\n  backendserver:\n    build: &quot;.&quot;\n    ports:\n      - &quot;8080:8080&quot;\n    depends_on:\n      postgres:\n        condition: service_healthy\n    network:\n      - test-network\n\nvolumes:\n  postgres:\n\nnetworks:\n  test-network:\n    name: test-network</code></pre></div>","frontmatter":{"title":"Using Docker with Postgres","date":"September 24, 2022","description":"Using Docker with Postgres","tags":["database","Docker"]}}},"pageContext":{"slug":"/Docker-with-postgres/","previous":{"fields":{"slug":"/service-on-raspberrypi/"},"frontmatter":{"title":"A web service deployed on Raspberry Pi based on Nginx","tags":["web","deployment"]}},"next":null}},"staticQueryHashes":["2841359383","3723978383"]}