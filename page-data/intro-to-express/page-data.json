{"componentChunkName":"component---src-templates-blog-post-js","path":"/intro-to-express/","result":{"data":{"site":{"siteMetadata":{"title":"PPX Blog"}},"markdownRemark":{"id":"b8e1f4b6-f67d-5a0f-b3db-b8a7671b357e","excerpt":"What is Express? Express is a Web framework based on node.js. It provides ways to recognize and respond to http request through Middleware and Router. Start To…","html":"<h3>What is Express?</h3>\n<p>Express is a Web framework based on node.js. It provides ways to recognize and respond to http request through Middleware and Router.</p>\n<h3>Start</h3>\n<p>To start using Express, we need to import express and create one instance using express(). To test the application, we also need a port and use the instance to listen to the port. This port can replace the real root dir and simulate the root page of the application.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const express = require(&#39;express&#39;)\nconst app = express()\nconst port = 3000\n\napp.listen(port, () =&gt; {\n  console.log(`Example app listening at http://localhost:${port}`)\n})</code></pre></div>\n<h3>Routing</h3>\n<p>Routing is the way to determining the response to the particular request. A route needs one method (GET, POST, PUT), one path and one or more handler callback function(s). An example is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get(&#39;/&#39;, function(req, res))</code></pre></div>\n<p>The path represents the location of the request requires to change. The req object represents the HTTP request and res represents the HTTP response that the app will send when it receive a request.</p>\n<h3>Serving static files</h3>\n<p>The work of the web application is the process of requests and responses. For example, when we open the main page of one web app, we send a request to GET index.html as a client. If such file is right in local dir, we can use express to get it directly as a static file. For example, if all our front-end file is in the dir path ’~/build’, we can use</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.use(express.static(&#39;build&#39;))</code></pre></div>\n<p>In this case, whenever the server receives the request to GET something, it will go to the build folder and look for the responded file. If there is no such file locally, Express will then go to the connected database to look for it through some condition (model schema).</p>\n<h3>Middleware</h3>\n<p>Middleware functions are functions that have access to req, res and the ‘next’ function. There are five types of middleware. The next function can assign the direction of the flow. If the middleware does not end the req, res cycle, a next() function is required to continue the flow into the next middleware function.</p>\n<h4>Application-level middleware</h4>\n<p>This middleware includes two methods, app.use() and app.METHOD().</p>\n<p>If the app.use() only has one argument, the callback function, it will be executed every time the app receives a request. If there is the path in the arguments, the function will executed every time the app receives a request on the path.</p>\n<h4>Router-level middleware</h4>\n<p>The router middleware needs to be bound to an instance of “require(‘express’).Router()“. It can be seen as a middleware between app middleware and router. The RLM can only perform middleware and routing functions. After we bound the RLM to some routers, we can execute app.use(path, router_instance) and that will execute the corresponding method we bound to RLM instance.</p>\n<h4>Error-handling middleware</h4>\n<p>Whenever we catch some error in the middleware and route handlers, we need to pass the error to Express through next(error). The error will then be passed into the build-in error handler. We can also write error handlers and this is the error-handling middleware.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.use(function(err, req, res, next) {})</code></pre></div>\n<p>We can handle different errors inside the function, and in the end, we can continue to use next(error) to pass the error we cannot handle now to Express.</p>\n<h3>Handle unknown endpoints</h3>\n<p>If the client send an request which is not defined in any middleware, we need to handle it by responding a 404. The way to handle writing and adding an unknown endpoint middleware after all app-level middleware and router-level middleware and before Error-handling middleware.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.use((request, response) =&gt; {\n    response.status(404).send({ error: &#39;unknown endpoint&#39; })\n})</code></pre></div>\n<p>To learn more about Express, view <a href=\"https://expressjs.com/en/5x/api.html\">API reference</a>.</p>","frontmatter":{"title":"Intro to Express","date":"August 02, 2020","description":"backend","tags":["backend","express","introduction"]}}},"pageContext":{"slug":"/intro-to-express/","previous":{"fields":{"slug":"/simple-parser/"},"frontmatter":{"title":"如何写一个简单的parser","tags":["compiler"]}},"next":null}}}