<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[PPX Blog]]></title><description><![CDATA[PPX's blog]]></description><link>https://xichen1.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 22 Dec 2020 14:02:12 GMT</lastBuildDate><item><title><![CDATA[MIT 6.828 Lab 1 Note]]></title><description><![CDATA[Introduction From today, I am going to share my experience in learning, implementing labs of MIT 6.828 in my blog. My background knowledge…]]></description><link>https://xichen1.github.io/6.828-lab1-note/</link><guid isPermaLink="false">https://xichen1.github.io/6.828-lab1-note/</guid><pubDate>Tue, 22 Dec 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;From today, I am going to share my experience in learning, implementing labs of MIT 6.828 in my blog.&lt;/p&gt;
&lt;p&gt;My background knowledge includes: C, computer architecture, RISC-V.&lt;/p&gt;
&lt;p&gt;I am going to use 2018 version material simply because there are most amount of resource about this version online.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/schedule.html&quot;&gt;Course homepage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labs/lab1/&quot;&gt;lab1 page&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Environment setup&lt;/h2&gt;
&lt;p&gt;First clone the course git repo, &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/jos.git&quot;&gt;Course Git reop&lt;/a&gt;. Then install toolchain, &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/tools.html&quot;&gt;install instruction&lt;/a&gt;. Note that if the Compiler Toolchain is already installed, the only thing needs to be installed is QEMU emulator. Next, lets compile the files in the Git repo.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sudo apt install gcc-multilib # if you are not under 32 bit environment
cd lab
make&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then type&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;make qemu&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We will successfully start JOS in the QEMU emulator. Now we boot the template OS and finish the setup of environment and lets take a look at the memory distribution in 32-bit machine.&lt;/p&gt;
&lt;h2&gt;PC’S address space &amp;#x26; PC start up process&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/55d5a040844645afe803a9725e8cac59/e85cb/pcmemory.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 120.27027027027026%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAYCAYAAAD6S912AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC00lEQVQ4y41Vi3KjMAzM///hdabtJeEZMG8MGIhuV0Aa0vQaz6g86iyrXUk+yPUqwzBoOOdkmiYN3m/vx3GUqqokNYmYBJEaqZtGLnEkdd0I1xU4XIfrPEnXtjLjeRydpGkqcRQrIDe1bYf7UbquA0itezvbSd/3kmeZWLzfA06j9NZKnpfy9/NT/DCQP29vcjyepAc7a3tl/L+1gd0A+VWuqsjlcrlIgrS6ftB3ZDiO0+2Hz2LHUK6z1NCHWlgwZWqMFh+p6xra1TLP129MfloH/qHwBGA0EJuxPfN/9+x+B8QmAhRlqU6S1cKs0ndkfp/WI/Bj+qqhBaC6DGeVIUCGwekPmsb+quED4KQuc824z42RDOHcArK4PMurC3U4i20bLZFnhd22Vq9FUYp39lAFiUqR5Ub8IJI0SSFLpbWbJGZhyJT3dfV1rymjsJk2q0A7Cg3g3IBq6PV5I8AG0E6xakqt5VMWhZpS4MpN7QuFvU95YusRsLrpV1YlUotl6F/vlC9TVoY/Vdji8gjQUfuXwdT5bhsc96A3U5g/U83Q8GWx1CQ3b6ZUYO0Hvvi+J8e/R/R+LmEQ6NR5mDaztGsdlnDP9wNJ0M9Znq0M20VLdA1l4MiKo0glMphMIdwdnLuBqoZD3ykjDgWCpph3FwXN1UkC9tizsC90bDX4AFlnWb5L+zCv4ys1mXx+vIOhL1F0kY/3D4nBiC6zbCZo7daBq9qByKKj27WmptzZVr+YgmGRg0FeaA+z1r40rOTsnVTDE2YlmVGa0+msTXEHiLIBQwKGYYS0UzmvHcEJTsBFw0Y1pH5RGEKaCqBGoniZ7nvA9Qh4Vl/WdvoDzkgCGJMijJpFPQ30dPcabhObeEyXhniBpwZsE/uV4fDtkJpAkeNLhXbDekixRpdDigXNdiQ7Bp8fB68yXI7R/naMMsb1en+80pQAzH3vLB6MYAc9Oxb+AbbxTxK8dKi0AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;PC&amp;#39;s physical address&quot;
        title=&quot;PC&amp;#39;s physical address&quot;
        src=&quot;/static/55d5a040844645afe803a9725e8cac59/e85cb/pcmemory.png&quot;
        srcset=&quot;/static/55d5a040844645afe803a9725e8cac59/12f09/pcmemory.png 148w,
/static/55d5a040844645afe803a9725e8cac59/e4a3f/pcmemory.png 295w,
/static/55d5a040844645afe803a9725e8cac59/e85cb/pcmemory.png 480w&quot;
        sizes=&quot;(max-width: 480px) 100vw, 480px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The important part for PC start up is only the lower 1MB part, because right now CPU is under Real mode and the only accessible memory is this part. In this part, the most important on is BIOS (basic IO system), because code in BIOS starts the normal PC start up. And the other part of this 1MB memory is mapped by peripherals, which means CPU can read/write the other part to manipulate peripherals.&lt;/p&gt;
&lt;h4&gt;An interesting history&lt;/h4&gt;
&lt;p&gt;The max memory 32-bit processor can handle is 4GB. So when the 64-bit processor came out, larger memory were used in PC. The modern PC usually put BIOS at the top of the memory, and to keep the backward compatibility for some old software, designer keeps a “hole” from 0x000A0000 to 0x00100000.&lt;/p&gt;
&lt;h3&gt;Use GDB to analyze the process of start up&lt;/h3&gt;
&lt;p&gt;Now open two terminals, move into the OS folder. In the first one, type&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;make qemu-nox-gdb&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This line starts the emulator and waits for the connection of GDB. And in the second terminal, type&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;make gdb&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This line starts GDB and connect it to the OS. The file .gdbinit configs GDB to debug the code executed in the boot of OS in QEMU.&lt;/p&gt;
&lt;h4&gt;Very first instruction&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[f000:fff0]    0xffff0:	ljmp   $0x3630,$0xf000e05b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the first line appears after we connect GDB and OS. It shows where does the processor fetch the very first instruction and what that instruction is when we boot a PC.&lt;/p&gt;
&lt;p&gt;Under the real mode, address is in the form of (segment base : offset). So in the above line, in [f000:fff0], 0xf000 is segment base and 0xfff0 is offset. For 0x3630, 0xf000e05b, 0x3630 is segment base and 0xf000e05b is offset. The way to transfer this form into physical form is:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;phyAddr = 16 * segment + offset = 16 * CS + IP&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And after translating, this line means the professor fetch instruction from address 0xFFFF0, and instruction inside is a jump instruction, and the target address is 0xF004 435B.&lt;/p&gt;
&lt;p&gt;So there is several natural questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Why did the designer put the very first instruction in this location (distance between here and end of BIOS is 0x100000 - 0xFFFF0 = 16 bytes)?&lt;/li&gt;
&lt;li&gt;Why don’t just put this instruction in the beginning of the BIOS?&lt;/li&gt;
&lt;li&gt;Considering it is a jump instruction, why not set the first instruction just at its target address?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first two questions can be answered together. We have to consider that each PC company has their own BIOS code, user can add BIOS code too. Also, different company designs different length of BIOS boot code, so if the user wants to add code, the place to add is uncertain. However, if instead, we put user created code in the beginning of BIOS, it is more convenient to manage. So normally we put BIOS boot code in the end of BIOS part.&lt;/p&gt;
&lt;p&gt;For the last question, because different PC has different length of BIOS boot code, for example, if this code is 1KB, the start address is 0x100000 - 0x400 = 0xFFC00. If the code is 2KB, the start address is 0xFF800. And it is not a good practice to adjust the first instruction address in each PC. So the rule is put a jump instruction at 0xFFFF0 and the target is defined by each company.&lt;/p&gt;
&lt;h2&gt;TO BE CONTINUE&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[Intro to Express]]></title><description><![CDATA[What is Express? Express is a Web framework based on node.js. It provides ways to recognize and respond to http request through Middleware…]]></description><link>https://xichen1.github.io/intro-to-express/</link><guid isPermaLink="false">https://xichen1.github.io/intro-to-express/</guid><pubDate>Sun, 02 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;What is Express?&lt;/h3&gt;
&lt;p&gt;Express is a Web framework based on node.js. It provides ways to recognize and respond to http request through Middleware and Router.&lt;/p&gt;
&lt;h3&gt;Start&lt;/h3&gt;
&lt;p&gt;To start using Express, we need to import express and create one instance using express(). To test the application, we also need a port and use the instance to listen to the port. This port can replace the real root dir and simulate the root page of the application.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const express = require(&amp;#39;express&amp;#39;)
const app = express()
const port = 3000

app.listen(port, () =&amp;gt; {
  console.log(`Example app listening at http://localhost:${port}`)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Routing&lt;/h3&gt;
&lt;p&gt;Routing is the way to determining the response to the particular request. A route needs one method (GET, POST, PUT), one path and one or more handler callback function(s). An example is:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;app.get(&amp;#39;/&amp;#39;, function(req, res))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The path represents the location of the request requires to change. The req object represents the HTTP request and res represents the HTTP response that the app will send when it receive a request.&lt;/p&gt;
&lt;h3&gt;Serving static files&lt;/h3&gt;
&lt;p&gt;The work of the web application is the process of requests and responses. For example, when we open the main page of one web app, we send a request to GET index.html as a client. If such file is right in local dir, we can use express to get it directly as a static file. For example, if all our front-end file is in the dir path ’~/build’, we can use&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;app.use(express.static(&amp;#39;build&amp;#39;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, whenever the server receives the request to GET something, it will go to the build folder and look for the responded file. If there is no such file locally, Express will then go to the connected database to look for it through some condition (model schema).&lt;/p&gt;
&lt;h3&gt;Middleware&lt;/h3&gt;
&lt;p&gt;Middleware functions are functions that have access to req, res and the ‘next’ function. There are five types of middleware. The next function can assign the direction of the flow. If the middleware does not end the req, res cycle, a next() function is required to continue the flow into the next middleware function.&lt;/p&gt;
&lt;h4&gt;Application-level middleware&lt;/h4&gt;
&lt;p&gt;This middleware includes two methods, app.use() and app.METHOD().&lt;/p&gt;
&lt;p&gt;If the app.use() only has one argument, the callback function, it will be executed every time the app receives a request. If there is the path in the arguments, the function will executed every time the app receives a request on the path.&lt;/p&gt;
&lt;h4&gt;Router-level middleware&lt;/h4&gt;
&lt;p&gt;The router middleware needs to be bound to an instance of “require(‘express’).Router()“. It can be seen as a middleware between app middleware and router. The RLM can only perform middleware and routing functions. After we bound the RLM to some routers, we can execute app.use(path, router_instance) and that will execute the corresponding method we bound to RLM instance.&lt;/p&gt;
&lt;h4&gt;Error-handling middleware&lt;/h4&gt;
&lt;p&gt;Whenever we catch some error in the middleware and route handlers, we need to pass the error to Express through next(error). The error will then be passed into the build-in error handler. We can also write error handlers and this is the error-handling middleware.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;app.use(function(err, req, res, next) {})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can handle different errors inside the function, and in the end, we can continue to use next(error) to pass the error we cannot handle now to Express.&lt;/p&gt;
&lt;h3&gt;Handle unknown endpoints&lt;/h3&gt;
&lt;p&gt;If the client send an request which is not defined in any middleware, we need to handle it by responding a 404. The way to handle writing and adding an unknown endpoint middleware after all app-level middleware and router-level middleware and before Error-handling middleware.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;app.use((request, response) =&amp;gt; {
    response.status(404).send({ error: &amp;#39;unknown endpoint&amp;#39; })
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To learn more about Express, view &lt;a href=&quot;https://expressjs.com/en/5x/api.html&quot;&gt;API reference&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[如何写一个简单的parser]]></title><description><![CDATA[起因 因为最近学了一点 js, 准备做几个项目练练手, 就盯上了万年老坑计算器. 说他坑主要是因为可易可难, 如果要加上很多科学计算器的功能估计会很麻烦. 于是我就准备做一个只有最基础四则运算功能的版本. 看了几篇给 js…]]></description><link>https://xichen1.github.io/simple-parser/</link><guid isPermaLink="false">https://xichen1.github.io/simple-parser/</guid><pubDate>Sun, 21 Jun 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;因为最近学了一点 js, 准备做几个项目练练手, 就盯上了万年老坑计算器. 说他坑主要是因为可易可难, 如果要加上很多科学计算器的功能估计会很麻烦. 于是我就准备做一个只有最基础四则运算功能的版本. 看了几篇给 js 初学者看的文章发现基本都是先从基本逻辑讲起, 再不断往上堆功能最后再考虑边际情况. 感觉这种方法又啰嗦又不 robust, 就突然想起了大一课上学过一个叫逆波兰表达式的东西(Reverse Polish notation), 貌似能很方便的计算任意的一个 expression, 然后我就把 js 扔在了一边开始研究怎么把给出的一个数学 expression 转换成 RPN 形式.&lt;/p&gt;
&lt;h3&gt;逆波兰表达式(RPN)&lt;/h3&gt;
&lt;p&gt;逆波兰表达式中的所有符号都在第二个操作数的后面
EX:
1 2 3 + *
在这个表达式里, +号在 3 后面, 所以+连接 2 和 3, 而*号在 2 和 3 后面, 所以*号连接 1 和(2+3).
使用 stack 后 RPN 的计算可以变得非常方便, 具体计算一个 RPN 值的方法是:
依次把 token 放进 stack, 遇到 operator 时把入栈的 token 数字都拿出并且用 operator 连接求值, 将值放进 stack. 遍历过一遍 RPN 后, stack 顶的值就是这个 RPN 的值.&lt;/p&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;但是使用 RPN 计算一个表达式的值有一个问题, 就是如何把普通的 expression 又称中缀表达式转换成 RPN. Wikipedia 告诉我可以用一个叫调度场算法的方法来 convert. 但由于其适应性不够(只能用在 RPN 问题中)而且貌似很难证明, 遂放弃. 而这个时候我发现了 parser 的存在.&lt;/p&gt;
&lt;h3&gt;Parser&lt;/h3&gt;
&lt;p&gt;根据&lt;a href=&quot;https://www.yinwang.org/blog-cn/2015/09/19/parser&quot;&gt;王垠的文章&lt;/a&gt;, parser 是能把文本转换成一种叫抽象语法树(AST)的数据结构的工具. 对于 1+2 这样的表达式, 计算机无法直接对其计算, 而要通过 AST 来计算他的值.
对于 1+2 这样的数学表达式来说 AST 是一个二叉树, 每一个 node 代表了一个操作符, 而二叉树的 leaf 则为最初始的操作数. //TODD: add img&lt;/p&gt;
&lt;p&gt;因此一个中缀表达式可以被转换成由操作符和操作数组成的无括号的二叉树, 而有了这棵二叉树, 中缀转 RPN 将会变得非常简单. 更简单的是我可以通过遍历这棵树来直接求得中缀 expression 的答案. 而 parser 要干的事, 就是自动地把任意一个 expression 转换成这棵 AST.&lt;/p&gt;
&lt;h4&gt;算法&lt;/h4&gt;
&lt;p&gt;于是问题就变成了如何造出一个 parser, which 能接受任意的带括号的四则运算表达式, 并且能输出一棵 AST.&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&quot;http://www.cppblog.com/vczh/archive/2008/06/15/53373.html&quot;&gt;轮子哥的博客&lt;/a&gt;, 我了解到一般编译器中用到的 parser 都是用一种叫递归下降的算法写的.&lt;/p&gt;
&lt;p&gt;我们可以先分析一下一个 expression 的语法. 一个 expression: 1+2&lt;em&gt;(3+4)/&lt;/em&gt;5+6/7-8, 我们可以把他分成三个部分, 一是最简单的 term. 一个 term 可以是一个数字, 也可以是由()围起来的一个 expression, 这么分是因()的值和数字值地位相同.&lt;/p&gt;
&lt;p&gt;其次我们可以把由*或/连接的元素称为 factor. 在例子中, 2*(3+4)/5 就是一个 factor, 这么分的原因是可以观察到所有 factor 中的被*或/连接的元素都是一个 term, 如 2, (3+4) 和 5. 要注意的是, 在实现的过程中, 要考虑只有一个 term 而不需要*或/来连接的情况,　这种情况下, 我们也称这个 term 为 factor.&lt;/p&gt;
&lt;p&gt;最后, 我们可以把由+或-连接的元素称为 expression. 在例子中如 1+2(3+4)/5+6/7-8, 和 3+4 这样的都被称为 expression. 这么划分 expression 的原因是由+或-直接连接的元素都是 factor. 要注意的是, 在实现过程中, 要考虑只有一个 term 而不需要+或-来连接的情况, 这种情况下, 我们也称这个 factor 为 expression.&lt;/p&gt;
&lt;p&gt;如 ”1“ 这个表达式, 他不需要加减号来连接, 因此他自己就是一个 expression, 也是一个 factor. 而他也没有乘除号来连接因此他也是一个 term.&lt;/p&gt;
&lt;p&gt;通过这种划分方法来递推 expression 的方法是这样的:&lt;/p&gt;
&lt;p&gt;EX: 1+2*3-4/5&lt;/p&gt;
&lt;p&gt;这是一个 expression, 含有 3 个 factors, 分别是 1, 2*3 和 4/5. 1 中含有一个纯数字 term 1, 这时我们就到了 AST 的底端, 而这个 leaf 的值, 就是这个 term 的值 1. 2*3 中含有两个纯数字 term 2 和 3, 而 2 和 3 可以分别被存放在最低端的两个 leaf 中, 值分别是 2 和 3. 而这两个 leaf 的 father node, 则存放了连接这两个 term 的 operator, 在这个例子中为*. 4/5 同理. 到目前为止,我们有了 3 个 factor&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 107px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b4ca681e2fb812e8f99db1bb045a14b3/a18c5/factor1.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 94.39252336448598%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGAABAQADAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHvRibEFAB//8QAFhAAAwAAAAAAAAAAAAAAAAAAACEw/9oACAEBAAEFAhw//8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFxAAAwEAAAAAAAAAAAAAAAAAAREgQf/aAAgBAQAGPwKCtn//xAAbEAEBAAIDAQAAAAAAAAAAAAABEQAxECBBYf/aAAgBAQABPyFZlG5PnDscIKVfGBAOn//aAAwDAQACAAMAAAAQcM88/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITFBURBx0f/aAAgBAQABPxCgYtcB3ENhcuR9hrZLgS6sQ6iuxBp6qZk0BCceP//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;factor1&quot;
        title=&quot;factor1&quot;
        src=&quot;/static/b4ca681e2fb812e8f99db1bb045a14b3/a18c5/factor1.jpg&quot;
        srcset=&quot;/static/b4ca681e2fb812e8f99db1bb045a14b3/a18c5/factor1.jpg 107w&quot;
        sizes=&quot;(max-width: 107px) 100vw, 107px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 306px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/874b97579aaf19fad035f7ddf04cd3d0/01fdd/factor2.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 78.37837837837837%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB34oQf//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABoQAAICAwAAAAAAAAAAAAAAAAAQAREhMUH/2gAIAQEAAT8hOrNqNH//2gAMAwEAAgADAAAAEADP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGBABAAMBAAAAAAAAAAAAAAAAAQARIRD/2gAIAQEAAT8QgPC0gZG6yNdYz//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;factor2&quot;
        title=&quot;factor2&quot;
        src=&quot;/static/874b97579aaf19fad035f7ddf04cd3d0/01fdd/factor2.jpg&quot;
        srcset=&quot;/static/874b97579aaf19fad035f7ddf04cd3d0/a80bd/factor2.jpg 148w,
/static/874b97579aaf19fad035f7ddf04cd3d0/1c91a/factor2.jpg 295w,
/static/874b97579aaf19fad035f7ddf04cd3d0/01fdd/factor2.jpg 306w&quot;
        sizes=&quot;(max-width: 306px) 100vw, 306px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 239px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3e5e22634ad3466b8607d3733894bc22/e5db7/factor3.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 91.21621621621621%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAASABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3kpUChAf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQABBQIf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAFBABAAAAAAAAAAAAAAAAAAAAMP/aAAgBAQAGPwIf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQESAhMf/aAAgBAQABPyF8FF7GJ3h//9oADAMBAAIAAwAAABCwCDz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAbEAADAQEAAwAAAAAAAAAAAAAAAREhMRBxkf/aAAgBAQABPxDTTokbyLwncTPQ0RFY/hFbNO9Fiw//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;factor3&quot;
        title=&quot;factor3&quot;
        src=&quot;/static/3e5e22634ad3466b8607d3733894bc22/e5db7/factor3.jpg&quot;
        srcset=&quot;/static/3e5e22634ad3466b8607d3733894bc22/a80bd/factor3.jpg 148w,
/static/3e5e22634ad3466b8607d3733894bc22/e5db7/factor3.jpg 239w&quot;
        sizes=&quot;(max-width: 239px) 100vw, 239px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;向上一级, 考虑 factor 组成的 expression. 程序先检测到 factor1 和 2*3, 然后 1 和*的 father node 就变成了+. 程序继续考虑 4/5 也是 factor, 于是+和/的 father node 变成了-.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f71b0bceb6961aa1fbb19acb97a13abc/073a0/result1.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.432432432432435%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3gUH/8QAFRABAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQEAAQUCa//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAAAAQATFBYf/aAAgBAQABPyE6qEav/9oADAMBAAIAAwAAABDAD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAAIDAAMAAAAAAAAAAAAAAAERACFBEFFh/9oACAEBAAE/ECcCcpIYCx7soalkPfH/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;result1&quot;
        title=&quot;result1&quot;
        src=&quot;/static/f71b0bceb6961aa1fbb19acb97a13abc/1c72d/result1.jpg&quot;
        srcset=&quot;/static/f71b0bceb6961aa1fbb19acb97a13abc/a80bd/result1.jpg 148w,
/static/f71b0bceb6961aa1fbb19acb97a13abc/1c91a/result1.jpg 295w,
/static/f71b0bceb6961aa1fbb19acb97a13abc/1c72d/result1.jpg 590w,
/static/f71b0bceb6961aa1fbb19acb97a13abc/073a0/result1.jpg 610w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;p&gt;我们先建一个 node class 作为存放 node 值的数据结构, 这个类中定义了该 node 是不是纯数字 term, 他的左右 child 分别是什么, 以及如果不是 leaf node, 他存放了什么 operator:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;struct Expression {
	bool Isnumber;
    int Number;
    char Operator;
    Expression *Left;
    Expression *Right;

    // arrive the bottom of the AST, only number on the node
    Expression(int aNumber) {
        Number = aNumber;
        Isnumber = true;
        Left = nullptr;
        Right = nullptr;
        Operator = 0;
    }

    // operator nodes of the AST
    Expression(char aOperator, Expression *left, Expression *right){
        Operator = aOperator;
        Left = left;
        Right = right;
        Isnumber = false;
        Number = 0;
    }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的构造函数分别是为后面建两种 node 准备的.&lt;/p&gt;
&lt;p&gt;我们需要至少三个函数, 来依次检测 expression, factor 和 term, 如果 term 中又出现了 expression, 则又需要调用检测 expression 的函数. 此外, 我们还需要检测 term 中是否是纯数字的函数, 如果是纯数字, 则需把数字存在 leaf node 中. 因此声明四个函数:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Expression *exp(char *&amp;amp;Stream);
Expression *factor(char *&amp;amp;Stream);
Expression *term(char *&amp;amp;Stream);
Expression *number(char *&amp;amp;Stream);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给出一个函数,　其他三个的实现方法类似&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Expression *expr(char *&amp;amp;Stream) {
    char *Read = Stream;
    Expression *t = fact(Read);
    if (t) {
        Expression *result = t;

        while (true) {
            char sign = 0;
            if (comp(Read, &amp;quot;+&amp;quot;)) {
                sign = &amp;#39;+&amp;#39;;
            } else if (comp(Read, &amp;quot;-&amp;quot;)) {
                sign = &amp;#39;-&amp;#39;;
            } else {
                break;
            }
            Expression *next = fact(Read);
            if (next) {
                result = new Expression(sign, result, next);
            } else {
                return nullptr;
            }
        }
        Stream = Read;

        return result;
    } else {
        return nullptr;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而最后遍历树求值的方法比较简单, 代码就不放了.&lt;/p&gt;
&lt;p&gt;因为最近才开始学 C++, 一些 C++11 的特性不是很熟悉, 很多还是用写 C 的经验写的. 代码等熟悉了还可以改进.&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;这次主要是写了个最简单的 parser, 然后解决了表达式计算值的问题, 其实也可以用这个 parser 转成 RPN 再求值, 不过那就要多一步 stack 操作的过程了. 网上的很多人说 parser 是实现编译器的第零步,这么看起来 compiler 也挺好玩的, 改天可以写个解析语言或者 json 这样文本的 parser 试试.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Hello World]]></title><description><![CDATA[Hello World! This is my first post on my blog!]]></description><link>https://xichen1.github.io/hello-world/</link><guid isPermaLink="false">https://xichen1.github.io/hello-world/</guid><pubDate>Mon, 15 Jun 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;Hello World!&lt;/h2&gt;
&lt;p&gt;This is my first post on my blog!&lt;/p&gt;</content:encoded></item></channel></rss>